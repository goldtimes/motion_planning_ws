#pragma once

#include <Eigen/Core>
#include <Eigen/Dense>
#include <memory>

// for creating a local cost grid
#include <base_local_planner/map_grid_visualizer.h>
// for obstacle data access
#include <costmap_2d/costmap_2d.h>
// 读取速度限制
#include <base_local_planner/local_planner_limits.h>
#include <base_local_planner/local_planner_util.h>
// 官方的实现dwa速度采样实现，真正是要阅读这里
#include <base_local_planner/simple_trajectory_generator.h>
// 轨迹评价部分
#include <base_local_planner/map_grid_cost_function.h>
#include <base_local_planner/obstacle_cost_function.h>
#include <base_local_planner/oscillation_cost_function.h>
#include <base_local_planner/simple_scored_sampling_planner.h>
#include <base_local_planner/twirling_cost_function.h>

#include <nav_msgs/Path.h>
#include "dwa_controller/DWAControllerConfig.h"

namespace mp::controller {
class DWA {
   public:
    DWA(std::string name, base_local_planner::LocalPlannerUtil* planner_util);
    void reconfigure(dwa_controller::DWAControllerConfig& cfg);
    bool checkTrajectory(const Eigen::Vector3f pos, const Eigen::Vector3f vel, const Eigen::Vector3f vel_samples);
    /**
        传入当前的位置和速度，生成轨迹
     */
    base_local_planner::Trajectory findBestPath(const geometry_msgs::PoseStamped& global_pose,
                                                const geometry_msgs::PoseStamped& global_vel,
                                                geometry_msgs::PoseStamped& drive_velocities);
    /**
       规划路径之前我们先更新cost
     */
    void updatePlanAndLocalCosts(const geometry_msgs::PoseStamped& global_pose,
                                 const std::vector<geometry_msgs::PoseStamped>& new_plan,
                                 const std::vector<geometry_msgs::Point>& footprint_spec);
    // 局部规划器的频率
    double getSimPeriod() {
        return sim_period_;
    }
    /**
        计算cost
     */
    bool getCellCosts(int cx, int cy, float& path_cost, float& goal_cost, float& occ_cost, float& total_cost);
    bool setPlan(const std::vector<geometry_msgs::PoseStamped>& orig_global_plan);

   private:
    base_local_planner::LocalPlannerUtil* planner_util_;

    double stop_time_buffer_;  ///< @brief How long before hitting something we're going to enforce that the robot stop
    double path_distance_bias_, goal_distance_bias_, occdist_scale_;
    // dwa的采样
    Eigen::Vector3f vsamples_;

    double sim_period_;  ///< @brief The number of seconds to use to compute max/min vels for dwa
    // 评分后的轨迹
    base_local_planner::Trajectory result_traj_;

    double forward_point_distance_;

    std::vector<geometry_msgs::PoseStamped> global_plan_;

    boost::mutex configuration_mutex_;
    std::string frame_id_;
    ros::Publisher traj_cloud_pub_;
    bool publish_cost_grid_pc_;  ///< @brief Whether or not to build and publish a PointCloud
    bool publish_traj_pc_;

    double cheat_factor_;

    base_local_planner::MapGridVisualizer map_viz_;  ///< @brief The map grid visualizer for outputting the potential
                                                     ///< field generated by the cost function

    // see constructor body for explanations
    base_local_planner::SimpleTrajectoryGenerator generator_;  // dwa的速度采样
    base_local_planner::OscillationCostFunction oscillation_costs_;
    base_local_planner::ObstacleCostFunction obstacle_costs_;
    base_local_planner::MapGridCostFunction path_costs_;
    base_local_planner::MapGridCostFunction goal_costs_;
    base_local_planner::MapGridCostFunction goal_front_costs_;
    base_local_planner::MapGridCostFunction alignment_costs_;
    base_local_planner::TwirlingCostFunction twirling_costs_;
    // 对generator_生成的轨迹做评价，取出最好的轨迹
    base_local_planner::SimpleScoredSamplingPlanner scored_sampling_planner_;
};
}  // namespace mp::controller